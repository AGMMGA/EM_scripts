import argparse
import glob2
import logging
import os
import re
import sys
import shutil
from math import ceil, log10

'''
filelist.txt is generated by UNIX command: find [starting_directory]-type f -name "*.mrc"
'''

class Micrograph_renamer(object):
    
    def __init__(self):
        super(Micrograph_renamer, self).__init__()
        self.build_parser()
        self.check = self.check_args()
    
    def build_parser(self):
        parser = argparse.ArgumentParser()
        parser.add_argument('-input_dir', help='Parent directory containing the data.'
                            ' Default: current directory')
        parser.add_argument('-output_dir', help='Destination directory.',
                            required=True)
        parser.add_argument('-filename', help='Example of filename pattern, '
                            'e.g. date_proj_###.mrc, where ### marks the incremental'
                            ' number',
                            required=True)
        parser.add_argument('-frames_suffix', help='The suffix for the frames. '
                            'Default: _frames_n#. "#" marks the positional number'
                            'An underscore wll be prepended')
        f = parser.add_mutually_exclusive_group()
        f.add_argument('-n_frames', help='The number of frames collected per image',
                       default=7, type=int)
        f.add_argument('-first_last', help='The first and last frames to be '
                       'integrated by motioncorr if -redo_integration is selected,'
                       'comma separated, starting from zero. Default 0,6')
        parser.add_argument('-f', help='Forces overwrite of existing files. '
                            'Otherwise existing files will be skipped', \
                            action = 'store_true')
        parser.add_argument('-jpg_dir', help='Export jpegs to this directory ')
        parser.add_argument('-EPU_image_pattern', help='some kind of pattern that denotes the'
                            'raw data images / frames. use "*" to take all mrc files')
        parser.add_argument('-redo_integration', help='re-integrate frames = True',
                            action = 'store_true')
        parser.parse_args(namespace=self)
        return parser
    
    def check_args(self):
        #input folder
        if not self.input_dir:
            self.input_dir = os.getcwd()
        else:
            if not os.path.isdir(self.input_dir):
                sys.exit('The input directory does not exist')
        
        #output directory
        if not os.path.isdir(self.output_dir):
            os.mkdir(self.output_dir)
                
        #counting the digits in the filename
        if '#' in self.filename:
            self.digits = self.filename.count('#')
            self.filename = self.filename.replace('#','{}',1).replace('#','')
        else:
            sys.exit('Please indicate with # where the incremental numbers'
                     ' are in the filename.\n'
                     'Es. -filename 2016_A_##.mrc for 2016_A_01.mrc, 2016_A_02.mrc, etc.')
        
        #making the jpg directory
        if self.jpg_dir:
            if not os.path.isdir(self.jpg_dir):
                os.mkdir(self.jpg_dir)
                
        #checking if we need to integrate different frames
        if self.n_frames and not self.first_last:
            self.first_frame = 0
            self.last_frame = int(self.n_frames)-1
        elif self.first_last:
            if not ',' in self.first_last:
                sys.exit('Please specify the first and last frame'
                         ' separated by comma, e.g. 0,6')
            try:
                self.first_frame = int(self.first_last.split(',')[0])
                self.last_frame = int(self.first_last.split(',')[1])
            except ValueError as e:
                e.msg = ('Please provide two numbers, comma separated for'
                          'first and last frame, e.g. 1,5')
                raise
        
        #sanity check of frames_suffix
        if not self.frames_suffix:
            self.frames_suffix = 'frames_n{}'
            self.frames_digits = ceil(log10(self.last_frame-self.first_frame))    
        else: #counting how many digits we expect for frame number
            if '#' not in self.frames_suffix:
                sys.exit('Please provide a # symbol in the frame_suffix to mark'
                         'the position of the incremental number')
            else: 
                #we happily ignore the number of '#' provided by the user
                #but we must remove all '#' except one for the program to work
                #hence the regexp hack
                temp = self.frames_suffix
                for pos in re.findall(re.compile('#'), self.frames_suffix)[1:]:
                    temp = temp[:temp.find(pos)]+temp[temp.find(pos)+1:]
                self.frames_suffix = temp.replace('#','{}')
                self.frame_digits = ceil(log10(self.last_frame-self.first_frame))
        
        #setting the default EPU_image_pattern
        if not self.EPU_image_pattern: # '' should be a valid pattern (i.e. all mrc files)
            self.EPU_image_pattern = '/Data/FoilHole'
        if self.EPU_image_pattern == '*':
            self.EPU_image_pattern = ''        
        return 1    
        
    def find_mrc_files(self, input_dir, EPU_image_pattern, frames_suffix):
        '''finds all the frames and integrated images that match the EPU image pattern
           and frame pattern'''
        mrc_list = glob2.glob(os.path.join(input_dir + '**/*.mrc'))
        mrc_list = [i for i in mrc_list if EPU_image_pattern in i] #discard wide fields
        frames_list = [i for i in mrc_list if frames_suffix[:-3] in i]# all frames
        integrated_list = [i for i in mrc_list
                           if self.frames_suffix[:-3] not in i]#all non-frames
        return frames_list, integrated_list
    
    def find_mrcs_files(self):
        pass #TODO
    
    def start_logger(self):
        log = os.path.join(self.output_dir, 'process_movies.log')
        logger = logging.getLogger(__name__) 
        logging.basicConfig(filename = log, level=logging.INFO)
        return logger
    
    def rename_files(self, frames_list, integrated_list):
        '''
        logic: 
        1 - start from integrated images, find corresponding frames, rename all
        2 - move frames to frames folder, images to images folder
        3 - if frames are left that have no corresponding image -> move them to orphan_frames
        4 - if images have less than the specified number of frames -> move image
        to orphan_images, frames to orphan_frames
        5 - re-rename all with proper zerofilling
        '''
        image_counter = 1
        image_dir = os.path.join(self.output_dir, 'integrated')
        frames_dir = os.path.join(self.output_dir, 'frames')
        orphan_images_dir = os.path.join(self.output_dir, 'orphan_integrated')
        missing_frames_dir = os.path.join(self.output_dir, 'missing_frames')
        orphan_frames_dir = os.path.join(self.output_dir, 'orphan_frames')
        os.makedirs(image_dir, exist_ok=True)
        os.makedirs(frames_dir, exist_ok=True)
        imgtemp = integrated_list.copy()
        frametemp = frames_list.copy()
        est_digits = ceil(log10(len(integrated_list))) #log10(# of images) rounded up
        while imgtemp:
            img = imgtemp.pop()
            root, _ = os.path.splitext(img)
            frame_root = root + self.frames_suffix
            frame_name = frame_root + '.mrc'
            t = frame_root.replace('{}','')
            frames = [f for f in frametemp if t in f]
            frames.sort() #let's attempt to keep the date order more or less
            if len(frames) == self.n_frames:
                #rename original image
                number = str(image_counter).zfill(est_digits)  
                new_img_name = os.path.join(image_dir,
                                    os.path.basename(self.filename.format(number)))
                shutil.move(img, new_img_name)
                #rename frames
                n = self.first_frame
                for frame in frames:
                    new_frame_name = new_img_name.replace('.', 
                                        self.frames_suffix.format(str(n)) + '.')
                    new_frame_name = os.path.join(frames_dir,
                                                  os.path.basename(new_frame_name))
                    shutil.move(frame, new_frame_name)
                    
                    n += 1
                    frametemp.remove(frame) # smaller list to traverse next time
            elif len(frames) != self.n_frames:
                os.makedirs(missing_frames_dir, exist_ok=True)
                os.makedirs(orphan_images_dir, exist_ok=True)
                new_img_name = os.path.join(orphan_images_dir, os.path.basename(img))
                shutil.move(img, new_img_name)
                n = self.first_frame
                for frame in frames:
                    new_frame_name = os.path.join(missing_frames_dir, os.path.basename(frame))
                    shutil.move(frame, new_frame_name)
                    frametemp.remove(frame)
                n += 1
            image_counter +=1
        if len(frametemp)>0: #some orphan frames are left
            for orphan_frame in frametemp:
                os.makedirs(orphan_frames_dir, exist_ok=True)
                a,b = (orphan_frame, os.path.join(orphan_frames_dir,
                                                    os.path.basename(orphan_frame)))
                shutil.move(a,b)
                
    def main(self):
        self.start_logger()
        frames_list, integrated_list = self.find_mrc_files(self.input_dir, 
                                                           self.EPU_image_pattern, 
                                                           self.frames_suffix)
        frames_list = frames_list.sorted()
        integrated_list = integrated_list.sorted()
        if self.redo_integration:
            mrcs_list = self.find_mrcs_files() #todo
        print (frames_list[:4])
        print(integrated_list[:4])

if __name__ == '__main__':
    a = Micrograph_renamer()
    a.main()

# project_name = '20160308_nucleo_xlink_data2'
# folder_pattern = re.compile('/Data/FoilHole')
# frames_pattern = re.compile('_n[0-6]')
# micrographs = []
# frames = True
# overwrite = True
# verbose = True
# n_frames = 7
# 
# os.chdir(data_folder)
# with open('filelist.txt') as f:
#     for line in f:
#         filename = os.path.join(data_folder,line[2:-1])
#         root, ext = os.path.splitext(filename)
#         if ext == '.mrc': #this should be a given, but let's check
#             occ = re.findall(folder_pattern, line)
#             if len(occ)>= 1: #it is an image of a hole
#                 frame = re.findall(frames_pattern, line)
#                 if filename.find('frames_n')==-1:
#                     micrographs.append(filename)
# 
# with open('logfile.txt','w') as log:
#     zeroes = math.ceil(math.log10(len(micrographs)))
#     counter = 1
#     for m in micrographs:
#         file_number = str(counter).zfill(zeroes)
#         new_micrograph_name = os.path.join(micrographs_dir, 
#                 '{0}_{1}.mrc'.format(project_name, file_number))
#         
#         shutil.copyfile(m, new_micrograph_name)
#         if verbose:
#             print ('{0} -> {1}\n'.format(m, new_micrograph_name))
#         log.write('{0} -> {1}\n'.format(m, new_micrograph_name))
#         
#         # copying frames
#         if frames:
#             old_frame_name = m.split('.mrc')[0] + '_frames_n{}.mrc'
#             for i in range(n_frames): #7 frames, starting from 0
#                 new_frame_name = new_micrograph_name .split('.mrc')[0] + \
#                     '_frames_n{}.mrc'.format(i)
#                 if os.path.isfile(old_frame_name.format(i)):
#                     shutil.copyfile(old_frame_name.format(i), new_frame_name)
#                 else:
#                     log.write('Not found: {} to go with {}\n'.format(old_frame_name.format(i),
#                             new_micrograph_name))
#                 if verbose:
#                     print ('{0} -> {1}\n'.format(old_frame_name.format(i), new_frame_name.format(i)))
#                 log.write('{0} -> {1}\n'.format(old_frame_name.format(i), new_frame_name.format(i)))
#         counter +=1